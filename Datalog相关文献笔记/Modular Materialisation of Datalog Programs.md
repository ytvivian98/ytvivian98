# Modular Materialisation of Datalog Programs

Datalog程序的模块化实例化

`19年RDFox相关的人的文章 `



## 摘要

​	seminaive算法可以用来实例化datalog程序的所有结果，并且它还构成了随着输入事实的变化逐步更新具体化的算法的基础。但是，使用自定义算法可以更有效地处理某些（组合）规则。为了将这些算法集成到可以处理任意规则的通用推理方法中，我们**提出了一个用于计算和维护实例化的模块化框架**。我们将数据记录程序拆分为可以使用专门算法处理的模块，并使用精算算法处理剩余的规则。我们还提出了两种算法，用于计算可在我们的框架内使用的关系的传递闭包和对称传递闭包。最后，我们凭经验表明，我们的框架可以处理任意数据记录程序，同时优于现有方法，通常高出几个数量级

## 1. Introduce

​	...

​	实例化和所有前面提到的增量算法使用seminaive评估来计算规则结果（Abiteboul、Hull 和 Vianu 1995）。这种方法的主要好处是每个适用的推理都只执行一次。然而，某些规则或规则组合的所有结果实际上都可以在不考虑每个适用推论的情况下计算出来。例如，考虑应用一个程序，该程序将关系 R 公理化为对称且可传递到描述由 n 个顶点组成的连通图的输入事实。在第 3 节中，我们展示了使用seminaive评估计算所有结果涉及 O(n<sup>3</sup>) 规则应用程序，而自定义算法只需 O(n<sup>2</sup>) 步即可实现相同的目标。由于增量维护算法基于seminaive算法，它们可能会遇到类似的缺陷。

​	在文献中已经考虑了可以维持特定Datalog程序的闭包的方法。例如，图的传递闭包的保持已被广泛研究(Ibaraki和Katoh 1983；La Poutre和van Leeuwen 1987；King 1999；Demetresu和Italiano 2000)。**Subercaze等人。(2016)给出了RDFS-Plus中传递性和对称性的实例化算法**。董、苏和Topor(1995)证明了传递闭关系的插入可以通过计算四个非递归的一阶查询来保持。然而，这些方法只能处理专门为其开发的数据记录程序-也就是说，程序不允许包含任何额外的规则。其他规则的存在带来了额外的复杂性，因为由专用算法计算的更新必须传播到其余规则，反之亦然。此外，这些方法中的许多方法不能处理输入事实的删除，这是增量推理中的关键问题。因此，目前尚不清楚定制的算法能否以及如何用于必须处理任意数据记录规则并支持增量添加和删除的通用数据记录系统。

​	为了解决这些问题，本文提出了一个物化计算和增量物化维护的模块化框架，该框架可以<font color=blue>**将专门的推理算法与Seminaive评估相结合**</font>。该框架将数据记录程序的规则划分为称为模块的互不相交的子集。对于每个模块，使用四个可插入函数来计算模块规则的某些结果；对于如何实现这些函数没有限制，只要它们的输出满足特定条件。此外，如果模块没有专门的算法可用，则可以使用Seminaive评估来实现这四个功能。因此，我们的框架可以有效地处理规则的某些组合，但它也可以处理任意规则，同时避免重复推理.

​	我们已经实现了我们的算法，并在几个现实生活和合成数据集上进行了比较。我们的实验说明了所提出的解决方案的潜在好处：我们的方法经常优于最先进的算法，有时是几个数量级的。我们的系统和测试数据可在网上获得。1 我们结果的所有证明都在一份技术报告中给出（Hu, Motik, and Horrocks 2018a）。

## 2. 先验知识

## 3. Motivation

​	在这一节中，我们展示了自定义算法如何比seminaive评估更有效地处理某些规则组合。我们在这里只考虑实例化，但类似的观察也适用于增量维护算法，因为它们大多使用了seminaive评估的变种。

### 3.1 seminaive算法

### 3.2 seminaive算法的问题

​	尽管seminaive评估并不重复推导，但它总是考虑每个适用的规则实例。然而，事实往往是通过多个不同的规则实例推导出来的；这在递归规则中特别常见，但它也可能只发生在非递归规则中。我们不知道有什么一般的技术可以防止这种推导。我们接下来介绍两个程序，对于这些程序，可以在不考虑所有适用的规则实例的情况下计算实例化，从而显示出半自动评估是如何做到次优的。

(说是直接用seminaive算法算传递闭包规则的时间复杂度是O(n<sup>3</sup>)) 它计算的规则实例形式是：

​	R( c<sub>i</sub>, c<sub>j</sub>) ∩ R(c<sub>j</sub>, c<sub>k</sub>) -> R( c<sub>i</sub>, c<sub>k</sub>)

​	我们接下来介绍一种方法的概要，这种方法在一般情况下仍然是立体的，但是在这种特定的输入中，运行时间为O(n<sup>2</sup>)。关键是要区分作为输入给Π的 "外部 "事实集X和由Π得出的 "内部 "事实。我们可以通过反复考虑R(u, v)∈X和R(v, w)这两对事实来过渡性地关闭R。也就是说，我们要求第一个事实在X中，但对第二个事实不加限制。(我们可以等价地要求第二个事实在X中)在我们的例子中，我们有X=E，所以算法只考虑以下形式的规则实例：

​	R( c<sub>i</sub>, c<sub>i+1</sub>) ∩ R(c<sub>i+1</sub>, c<sub>k</sub>) ->  R( c<sub>i</sub>, c<sub>k</sub>)	0<= i < k < n

